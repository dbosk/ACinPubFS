\section{Construction and Analysis of the Push Model}
\label{PushAnalysis}

The idea of the Push Model is for each subscriber to have an inbox in the file 
system --- as opposed to the Pull Model, where the publisher has an outbox.
This is simply a file object with a randomly chosen identifier.
The publisher then puts all published material in the inbox of each subscriber.

We can see that if we simply put the broadcast ciphertext from the Pull Model 
in all inboxes, then Eve can relate them since they contain identical 
ciphertexts.
We thus have to make some more modifications.
We will base our analysis on the following definition.

\begin{definition}[Push Model]\label{PushModel}
  Let \(\mathcal{E} = (\KeygenOp, \EncOp, \DecOp)\) be an authenticated 
  encryption scheme and \(\FSop\) be a public file system.
  We denote by \(\Push[p, S]\) the \emph{push model protocol} implementing 
  a \((p, S)\)-communication model through the operations
  \begin{itemize}
    \item \(\pnsetup[p, S]{p}[\cdot]\) and \(\pnsetup[p, S]{s}[\cdot]\),
    \item \(\pnpub[p, S]{p}[\cdot][\cdot]\), and
    \item \(\pnget[p, S]{s}[\cdot]\)
  \end{itemize}
  as in \cref{PushFunctions}.
\end{definition}

\begin{figure}%[p]
  \framebox{%
  \begin{minipage}[t]{0.48\textwidth}
    \begin{algorithmic}
      \Function{$\pnsetup[p, S]{p}$}{$1^\lambda$}
        \For{$r\in S$}
          \State{$(\SignKey{r}, \VerifKey{r})\rgets \Keygen{1^\lambda}$}
          \State{Give $\VerifKey{r}$ to $\Push[p, S][r]$.}
        \EndFor{}
      \EndFunction{}

      \Statex{}

      \Function{$\pnpub[p, S]{p}$}{$R, m$}
        \For{$r\in R$}
          \State{$c_r\gets \Enc[\PubKey{r}, \SignKey{r}]{m}$}
          \State{$\fswrite[i_r][c_r]$}
        \EndFor{}
      \EndFunction{}
    \end{algorithmic}
  \end{minipage}
  \begin{minipage}[t]{0.48\textwidth}
    \begin{algorithmic}
      \Function{$\pnsetup[p, S]{s}$}{$1^\lambda$}
        \State{$(\PubKey{s}, \PriKey{s})\rgets \Keygen{1^\lambda}$}
        \State{$i_s\rgets \{0, 1\}^{\lambda}$}
        \State{Give $(\PubKey{s}, i_s)$ to $\Push[p, S][p]$.}
      \EndFunction{}

      \Statex{}

      \Function{$\pnget[p, S]{s}$}{}
        \State{$C\gets \fsread[i_s]$}
        \If{$C = \bot$}
          \State{\Return{$\emptyset$}}
        \EndIf{}
        \State{$M\gets \emptyset$}
        \For{$c\in C$}
          \State{$m_c\gets \Dec[\PriKey{s}, \VerifKey{s}]{c}$}
          \If{$m_c\neq \bot$}
            \State{$M\gets M\cup \{m_c\}$}
          \EndIf{}
        \EndFor{}
        \State{\Return{$M$}}
      \EndFunction{}
    \end{algorithmic}
  \end{minipage}
  }
  \caption{%
    Functions implementing the communication model for the Push Model protocol.
    The publisher's interface is to the left and the subscribers' to the right.
  }\label{PushFunctions}
\end{figure}

When Alice executes \(\pnsetup{p}\) the \(\KeygenOp\) algorithm generates 
a signature-verification key-pair \((\SignKey{s}, \VerifKey{s})\) for every 
subscriber \(s\in S\) and gives the verification key to all her 
friends.\footnote{%
  Since the scheme \(\mathcal{E}\) is an authenticated encryption scheme, the 
  key generation yields a public-private key-pair and a signature-verification 
  key-pair --- in Alice's case (conversely for her friends) we are only 
  interested in the authentication part, so we simply discard her encryption 
  keys in the definition.
}
Each of her friends \(s\in S\), when they execute \(\pnsetup{s}\) the 
\(\KeygenOp\) algorithm generates a public-private key-pair.
Additionally they randomly choose a string as an identifier for their inbox.
They give the public key and the identifier to Alice.

When Alice wants to send a message \(m\) to a subset \(R\subseteq S\) of her 
friends, she uses \(\pnpub{p}\) to create the authenticated ciphertexts 
\(c_s\gets \Enc[\PubKey{s}, \SignKey{s}]{m}\) for each friend \(s\in R\).
The encryption scheme simply combines the recipients public key \(\PubKey{s}\) 
and Alice's friend-specific signature key \(\SignKey{s}\).
Then she uses \(\FS\) to append the ciphertext \(c_s\) to the file with 
identifier \(i_s\).

The operation \(\pget{s}\) works similarly as in the Pull Model, however, it 
uses a different file.
It starts by reading the inbox from the file system.
Then it iterates through the list of entries, decrypting each entry.
Each entry, if successfully decrypted, is a new message.
It appends the message to the list of messages which it returns upon 
finishing.

Note that, similar to the Pull Model, the authenticated encryption scheme 
\(\mathcal{E}\) can be a symmetric-key scheme although we use the notation of 
public-key cryptography in our abstraction.
We can simply let \(\PubKey{} = \PriKey{}\) and \(\SignKey{} = \VerifKey{}\) to 
achieve this.
This makes the Push Model modular as well.

% XXX Write high-level analysis of push model
Let us now look at what Eve can do in this model.
We start by looking at the ANO-IND-CCA game (\cref{ANO-IND-CCA}).
In the Push Model setting Eve can actually win this game with non-negligible 
advantage:
She starts by publishing a message (through the publication oracle) to each 
user.
Then she selects two sets of users, gives those to the challenger.
When the challenger publishes the message, Eve just observes which inboxes are 
written to and then she knows with absolute certainty which set was used.

To deal with this problem, we will introduce a mix-net.

\begin{definition}[Mix-net]\label{MixNet}
  Let \(m_1, \ldots, m_k\) be messages from senders \(1, \ldots, k\).
  A mix-net is a functionality \(\M\) such that on inputs \(m_1, \ldots, m_k\) 
  the outputs \(\M[1](m_1), \ldots, \M[k](m_k)\) are unlinkable to its senders.
  More specifically
  \begin{equation*}
    \Pr[i\mid \M[i](m_i)] = \Pr[i] = \frac{1}{k}.
  \end{equation*}
\end{definition}

The mix-net will not do much help in a single instance.
If all inputs to the mix-net are related, then so will the outputs and Eve will 
still not have any problem winning the ANO-IND-CCA game.
We must have one instance per input, and thus, with this construction we must 
run several instances in parallel to achieve any security.

\subsection{Running Multiple Push Instances in Parallel}
\label{ParallelPush}

There are two issues we must consider when running the Push Model in parallel.
First, as in the Pull Model, we must convince ourselves that Eve cannot 
distinguish between parallel instances of the Push Model.
Thereafter we can continue our discussion of using the mix-net to mix different
instances together.

To convince ourselves that two instances are indistinguishable we give the 
following theorem and proof.

\begin{theorem}
  Given two instances \(\Push[p, S]\) and \(\Push[p^\prime, S^\prime]\), \(p\) 
  and \(p^\prime\) are unlinkable for any adversary \(\A\).
\end{theorem}

\begin{proof}
  We will prove this by an information-theoretic argument.
  We have two cases: first, the two instances are unrelated, \(p\neq 
    p^\prime\); second, the two instances are either related or unrelated while 
  \(p = p^\prime\).
  We focus on the latter.
  In this case there are two possibilities, \(p\) created two instances and 
  they are thus unrelated.
  If they are related \(p\) must have used \(\psplit[p, S^*]{p}\) to form them 
  from some \(S^* = S\cup S^\prime\).
  In doing this, \(p\) randomly chooses \(i_0, i_1\in \{0, 1\}^\lambda\) and 
  \(\SignKey{0}, \SignKey{1}\rgets \Keygen{1^\lambda}\).
  This means that \((i_0, \SignKey{0})\) and \((i_1, \SignKey{1})\) are 
  information-theoretically independent.
  It follows from \cref{SplitGroupIsSecure} and the ANO-IND-CCA property of the 
  encryption scheme that even to \(s\in S\), nothing related to 
  \(\Pull[p^\prime, S^\prime]\) can be found.
  Thus we could equally likely have \(p\neq p^\prime\).
  \qed{}
\end{proof}

Even then, we cannot achieve negligible probability for Eve to win (as for the 
Pull Model).
All we can achieve is a lower bound.
It is a lower bound since the result depends on the behaviour in the parallel 
instances --- which will not be uniformly random.


