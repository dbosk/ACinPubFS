\title{%
  Privacy-Preserving Access Control in
  Decentralized Online Social Networks using
  Anonymous Broadcast Encryption
}
\author{%
  Daniel Bosk \and
  Sonja Buchegger
}
\institute{%
  School of Computer Science and Communication\\
  KTH Royal Institute of Technology, Stockholm, Sweden\\
  Email: \email{\{dbosk,buc\}@kth.se}%
}
%\date{24th March 2015}

\mode<presentation>{%
  \begin{frame}<presentation>
    \titlepage{}
  \end{frame}
  \begin{frame}<presentation>{Overview}
    \tableofcontents
  \end{frame}
}
\mode<article>{\maketitle}

\mode* % required for slides to compile without non-frame text

\begin{abstract}
  % XXX Update the abstract
  Online social networks collect and store large amounts of private data.
  Trusting too much data with third parties is a privacy risk.
  For this reason \acp{DOSN} was proposed.
  The current research on access control in \acp{DOSN} has focused on 
  efficiently achieving confidentiality for data.
  We focus on achieving efficient privacy-preserving access control mechanisms 
  for the \ac{DOSN} setting, i.e.~hidden policies, hidden credentials and 
  hidden decisions.
  We utilize the \ac{DOSN} setting to adapt \ac{ANOBE} for better performance.
  In this work we evaluate the privacy properties and the complexity of 
  different trade-offs.

  \keywords{%
    decentralized online social networks,
    access control,
    decentralized storage,
    anonymous broadcast encryption,
    hidden policies,
    hidden credentials,
    hidden decisions
  }
\end{abstract}

% Since this a solution template for a generic talk, very little can
% be said about how it should be structured. However, the talk length
% of between 15min and 45min and the theme suggest that you stick to
% the following rules:
% - Exactly two or three sections (other than the summary).
% - At *most* three subsections per section.
% - Talk about 30s to 2min per frame. So there should be between about
%   15 and 30 frames, all told.

\acresetall{}
\section{Introduction}
% XXX Ensure good structure:
% 1) what is the concrete setting that we consider (entities and their props),
% 2) what overall functionality and security properties do we want,
% 3) how are these properties realized (protocols, composition)?

\mode<presentation>{%
\subsection{Problem Setting}
\begin{frame}
  \begin{itemize}

    \item \acp{OSN} collect and store large amounts of private data.

    \item This data can reveal sensitive information.

    \item Even its meta-data can reveal a lot of information.

    \item Keeping this data out of our own control is thus a risk for privacy 
      violations.

  \end{itemize}
\end{frame}
}

Online social networks collect and store large amounts of private data.
Data mining is used to monetize these data through user profiling for directed 
advertisements or selling to third parties.
We know that this data is sensitive, even its meta-data, and can tell a lot 
about us~\cite[e.g.][]{pregnancy}.
We have later learned that government agencies, like the \ac{NSA} and 
\ac{GCHQ}, are interested in the data found in such centralized storage 
\cite{prism}.
Keeping this data out of our own control is thus a risk for privacy violations.

\begin{frame}<presentation>
  \begin{itemize}

    \item In our work we want to decentralize the \ac{OSN}
      \begin{itemize}
        \item to get away from a central provider,
        \item to keep the users in control of their data.
      \end{itemize}

    \item This way the users will control their data.

    %\item The system gets increased censorship resistance.

  \end{itemize}
\end{frame}

These risks were considered already in 2009 and to provide against these 
\acp{DOSN} were suggested~\cite[e.g.][]{peerson}.
\ac{DOSN} come with the benefits that users can keep control of their data, 
there is no central provider through which third parties (by force) can access 
it, and it is more difficult to censor.
However, such systems require more research to ensure security and privacy, as 
the decentralized structure opens up for other risks---even when data is 
encrypted~\cite{DevilInMetadata}.

% XXX Emphasize the main purpose of the work
In this work, we focus on \ac{AC} in such decentralized systems.
The main aim of \ac{AC} is to provide confidentiality for the user data.
There are several approaches to implementations, the classical approach is to 
rely on a \ac{TTP} as a reference monitor~\cite{AccessControl}.
Centralized \acp{OSN} such as Facebook or Google+ are examples of using 
a \ac{TTP}, and the Snowden revelations~\cite{prism} have proved that a risk.
Another way to implement the reference monitor is through cryptography.
With cryptography we remove the need for trust.
This way anyone may read the encrypted data and we can be sure that only those 
to whom we have given the proper keys can read it.
This is the approach we explore in this paper.
Previous research has already identified many pitfalls in this approach, 
e.g.~\cite{DevilInMetadata}, thus the purpose is not to find pitfalls, but to 
find efficient mechanisms to avoid them.

\citet{TowardsPPACwHPHCHD} identified three desirable properties for 
a privacy-preserving \ac{AC} mechanism, they also conjectured that these are 
sufficient.
The properties are:
\begin{description}
  \item[Hidden-Credentials] The reference monitor cannot learn a subject's 
    credentials, despite using them in the access decision.
    As such, the reference monitor cannot track which subjects are requesting 
    access.
  \item[Hidden-Policies] The access policy remains hidden from the subjects, 
    i.e.\ the subjects cannot learn which other subjects can access the same 
    object.
  \item[Hidden-Decisions] The reference monitor cannot learn the outcome of an 
    access decision, but the policy is still enforced.
\end{description}

\subsection{Our Contributions}
\mode<presentation>{%
\begin{frame}
  \begin{itemize}

    \item The main aim of \ac{AC} is to provide confidentiality for the user 
      data.

    \item Remember, we do not trust the storage to enforce \ac{AC}.

    \item So we rely on cryptography instead.

  \end{itemize}
\end{frame}

\begin{frame}<presentation>
  \begin{itemize}

    \item But simply encrypting the data and sharing keys with authorized 
      people is not good enough.

    \item This doesn't reveal the data itself, but reveals meta-data, e.g.:
      \begin{itemize}
        \item who may access what,
        \item who does access what.
      \end{itemize}

  \end{itemize}
\end{frame}
}

% XXX Improve the problem statement
% - Clearly describe the problem before any solution
% - What functional and security properties do we want?
% - What properties do we need?
%   - Do we need anonymity?
%   - Can we make a trade-off which is good enough?
As mentioned above, we want to create an \ac{AC} mechanism for a decentralized 
storage system, with minimal trust in other entities.
Naturally, the first property we want is confidentiality for the data.
Beyond confidentiality, we want the \ac{AC} mechanism to provide the 
privacy-preserving properties given above:
\begin{inparablank}
\item hidden policies,
\item hidden credentials, and
\item hidden decisions.
\end{inparablank}

% XXX Write an overview of our contributions and outline the paper
% - We have simplicity, more performance?
% - What are the benefits of our scheme?
In this extended abstract we outline our solution using \ac{ANOBE} and the 
methodology for evaluating the different designs.
In Sect.~\ref{sec:SystemModel} we describe our model, i.e.~the assumptions 
about the underlying systems.
In light of this model we present the problem in more detail in 
Sect.~\ref{sec:ProblemStatement} and in Sect.~\ref{sec:RelatedWork} we present 
related work.
Section~\ref{sec:ANOBE} gives an overview of the desirable properties of the 
\ac{ANOBE} scheme~\cite{anobe}, motivating our adoption for the \ac{DOSN} 
setting.
Section~\ref{sec:Contribution} outlines our approach to solutions and 
Sect.~\ref{sec:Evaluation} treats how we plan to evaluate these.


\section{Related Work}\label{sec:RelatedWork}
% XXX Add a summarizing intro paragraph to Related Work
The work of \citet{TowardsPPACwHPHCHD} focused on a general solution for 
privacy-preserving \ac{AC}.
They built their solution on fully homomorphic encryption, and, as such, the 
scheme is not yet practically feasible.
However, there is also a body of work which is practically feasible and applied 
in our setting.
There are several proposals for \acp{DOSN} available, e.g.~DECENT
\cite{decent}, Cachet~\cite{cachet} and Persona~\cite{persona}.
Their \ac{AC} mechanisms focus on providing confidentiality for the 
data.
For this they use \ac{ABE}~\cite{abe} to implement the \ac{AC} mechanism.
Unfortunately, this yields lacking privacy as \ac{ABE} is not policy-hiding, 
thus anyone can read the \ac{AC} policies and see who may access what data.

\citet{predicateac} adapted \ac{PE} for the \ac{AC} mechanism in \acp{DOSN}.
% XXX What properties did the PE scheme achieve?
The scheme achieved properties X.
% XXX What are the problems with the PE scheme?
% - More flexibility but less scalability?
The storage complexity for keys is exponential for the \ac{PE} scheme, it 
requires \(O(2^g)\) keys, where \(g\) is the number of groups a user is 
a member of.
The key size is also bound to the expressibility of the policy, e.g.\ I can 
estimate from the size of my key how many other individuals and groups are 
accounted for in the policy.
As this scheme reveals such meta-information, it is not satisfactory.

\subsection{Broadcast Encryption}\label{sec:BE}

The purpose of \ac{BE}~\cite{broadcastenc} was to develop methods to 
efficiently transmit data to a dynamically changing target audience 
\(S\subseteq U\) who are allowed to read the data, whereas the remaining users 
\(U\setminus S\) are not.
This fits our use-case well.
However, most research in \ac{BE} has focused on efficiency and not privacy.
Thus schemes usually require that the set \(S\) is revealed as it is required 
for the members \(s\in S\) to know \(S\) for decryption.
\citet{gunther2012cryptographic} adapted a \ac{BE} scheme using pseudonyms, but 
pseudonyms yield a limited anonymity property~\cite{gunther2012cryptographic}.
Due to this limitation of \ac{BE} schemes, \citet{anobe} developed \ac{ANOBE}, 
where the goal is to allow decryption without knowing \(S\).
% XXX Why is ANOBE expensive?
The complexity of the \ac{ANOBE} scheme is linear in the size of the recipient 
set, i.e.~\(O(|S|)\), whereas constant-size ciphertexts\footnote{%
  This does not include the description of the set \(S\), which is needed for 
  decryption.
  So we should add another \(|S|\) bits per ciphertext (if we do not use any 
  type of coding scheme to reduce it further).
}, \(O(1)\), has been achieved for non-anonymous \ac{BE}.

\subsection{Anonymous Broadcast Encryption}\label{sec:ANOBE}
% XXX Describe ANOBE properly
% - How is the key \(k\) distributed?
The main idea of \ac{ANOBE} is to distribute a key \(k\) to a subset of users, 
such that they can decrypt the broadcast message encrypted with \(k\) but no 
one else can.
The users who receive \(k\) should not be able to figure out who else received 
\(k\) and who did not.
This is a suitable mechanism for \ac{DOSN} as publishing a message to all 
friends is basically a broadcast to all or a subset of friends in the network.

The \ac{ANOBE} scheme was specifically designed to hide the recipient set.
This is an important property as all ciphertexts are world-readable.
If we do not have this property, then a non-intended recipient \(u\notin S\) 
can learn who is a valid recipient.
If \(u\notin S\) learns the recipient set \(S\), then \(u\) might target the 
users in \(S\) to learn the broadcast data.
It is also of interest that the privileged users \(s\in S\) cannot see who else 
is in \(S\).
In this case, a user \(s\in S\) might tell \(u\notin S\) about the message and 
blame another user \(s^\prime\in S\) for leaking.
But if \(s\in S\) might be the only person to learn the broadcast message, he 
might be discouraged to tell \(u\) as he might be the only one to blame.

For \ac{ANOBE} to accomplish this, we require an encryption scheme which is 
key-private~\cite{KeyPrivacy}.
This property ensures that, given a ciphertext, an eavesdropper cannot tell 
which public key, out of a set of public keys, was used to generate the 
ciphertext.
Another property we need for the encryption scheme is 
robustness~\cite{RobustEncryption}.
Robust encryption ensures that we cannot create a ciphertext which is valid for 
two different recipients:
if we have a set of possible recipients \(R\), we encrypt a message for one of 
them, \(r\in R\), then all \(r^\prime\neq r\) must decrypt the ciphertext to an 
invalid message under their keys.


\section{System Model}\label{sec:SystemModel}
% XXX Improve the summarizing intro paragraph in System Model
The system model we work in will be relevant to our design.
Thus we need to make some assumptions about the entities and their 
properties.
We also need to make assumptions about the properties of the underlying 
communication system.
Finally, there are different ways to implement the \ac{DOSN} architecture, and 
we cover the two extremes.

\subsection{The Entities and Their Properties}
% XXX Clarify the entities and their properties
\mode<presentation>{%
\begin{frame}<presentation>
  \begin{itemize}

    \item We assume there exists a distributed storage system:
      \begin{itemize}
        \item All users can create new objects.
        \item Any user can read any object.
        \item Only the owner can modify an object.
        \item An owner can optionally allow others to append.
      \end{itemize}

    \item Since it's distributed we have a set of distributed storage nodes.

  \end{itemize}
\end{frame}
}

The main entities are users (or \emph{subjects}) who want to access 
\emph{objects} stored on different \emph{storage nodes}.
In essence, the storage nodes can be thought of as \ac{WWW} servers which serve 
only static objects, ciphertexts in our case.
More specifically, we want the following properties.
All users can create objects with unique names, i.e.\ analogous publishing 
static content on the \ac{WWW}.
The object name is actually a \ac{URI}~\cite{rfc3986}:
one part of the name indicates the address of the object, i.e.\ which storage 
node that holds the object;
the remaining part of the name makes the object uniquely identifiable in the 
storage node.
All objects are world readable and only the owner of an object can modify it.
However, we optionally have an append operation which is available to all 
users, provided that the owner has enabled it for the object in question.
% XXX Put a good reference to NebuloStore here

\mode<presentation>{%
\subsection{Trust}
\begin{frame}<presentation>
  \begin{itemize}

    \item The users have limited trust in the storage nodes.

    \item We trust the storage nodes to keep \enquote{something} online.

  \end{itemize}
\end{frame}
}

We want the users to have limited trust in the storage nodes.
Users can trust that the storage node will keep the data available 
\cite{dataavailability,replicaplacement}, but we do not want them to trust the 
nodes more than that.
We assume that users and storage nodes set up some scheme for (possibly 
anonymous) authentication when they agree on the \enquote{storage contract} for 
replica placement~\cite{replicaplacement}.

\subsection{The Underlying Communication}

\mode<presentation>{%
\begin{frame}<presentation>
  \begin{itemize}

    \item We also assume that we can anonymize the users and storage nodes.

    \item This can be accomplished using e.g.~Tor.

  \end{itemize}
\end{frame}
}

We assume that the underlying communication is run on top of an anonymization 
network, e.g.\ using onion routing as in Tor~\cite{Tor}.
This way we can assume that the users and storage nodes remain anonymous.
More specifically, we want the origin of two requests to be
indistinguishable to the storage node, so the storage node cannot differentiate 
between the same user making two requests or two users making one request each.

\subsection{The \acs{DOSN} Architecture}
% XXX Describe the DOSN architecture, push vs pull
% - Clarify the set-up assumptions, how do the user get the encrypted data?
There is the push model and the pull model.


\section{Adversary Model}
% XXX Describe the adversary model
\dots


\section{Our Construction}\label{sec:Contribution}
% XXX Describe our approach
% - "If we simplify like this, then we get these problems"
% - Recap what functional and security properties we want.
% - How can we achieve these properties?
% - Be careful with the trivial.

We can use cryptographic mechanisms to ensure integrity of the data, i.e.\ that 
we can detect if the data is modified by someone else than the owner.
We can use the signature scheme to detect changes to an object made by someone 
other than the owner.

Every user in the \ac{DOSN} has a profile and each user knows the name of the 
objects which hold the profiles of their friends.
From this profile a friend can find the names of other related objects, 
e.g.~posts and comments.
Further, the profile owner can group these users (possibly overlapping) to show 
each group a different version of the profile, e.g.~one for private relations 
and one for professional ones.

%\begin{frame}<presentation>
%  \begin{itemize}
%
%    \item We can achieve Hidden-Credentials since we use crypto.
%
%    \item I'm allowed to access the object if I have a key which can decrypt 
%      it.
%
%    \item This will not reveal the credential to the storage node.
%
%  \end{itemize}
%\end{frame}

% - Where does the secret key come from?
The hidden-credentials property is trivially achieved in our cryptographic 
setting: the user's secret key serves as a credential to allow access.
As all users can read an object and every user is anonymous, then there is no 
need for a user to show any type of credential to the storage provider and the 
storage provider cannot identify any of the users.
Thus the access credentials are hidden.

%\begin{frame}<presentation>
%  \begin{itemize}
%
%    \item We similarly achieve Hidden-Decisions.
%
%    \item The storage node cannot tell if the \ac{AC} decision is positive or 
%      negative.
%
%    \item As I alone know if I can decrypt or not.
%
%  \end{itemize}
%\end{frame}

% - If the user only downloads ciphertexts he can decrypt, then this doesn't 
%   hold.
The hidden-decisions property is also trivially achieved in our cryptographic 
setting: a user requests a ciphertext, the storage provider does not learn 
whether the user can decrypt it or not.
Thus the access decisions are hidden.

\begin{frame}<presentation>
  \begin{itemize}

    \item The last property is the Hidden-Policies.
      
    \item This requires that there is no \ac{ACL} indicating who can decrypt.

    \item This is a problem we need to solve, since it requires a lot of 
      computation doing trial-and-error to see if I can decrypt or not.

  \end{itemize}
\end{frame}

The last property, hidden policies, states that no user shall learn anything 
about who else is authorized or unauthorized to access a certain object.
As we will see in Sect.~\ref{sec:RelatedWork}, this is difficult to achieve 
efficiently.
%This can be solved by encrypting for every authorized user and sending them the 
%resultant ciphertext.
%This way no user can see whether another is granted access or not.
%The problem is that this scheme has a storage complexity linear in the number 
%of users (when using a public-key encryption scheme): first one key per user 
%and then one ciphertext per user.
%The computational complexity is also linear in the number of users as we have 
%to do one encryption per recipient.
Our work focuses on finding a more efficient solution to this problem.

\subsection{The Scheme}

\mode<presentation>{%
\begin{frame}<presentation>
  \begin{itemize}

    \item We adapt \ac{ANOBE} to hide the policy.

    \item \ac{ANOBE} as it is, is inefficient.

  \end{itemize}
\end{frame}
}

There are several ways to distribute messages in \acp{DOSN}.
We can broadly categorize them as either a pull or a push model.
In the pull model, all friends actively pull updates from a user's profile, 
e.g.~when they go online to look for updates.
In the push model, the profile owner pushes change notifications to all 
friends' whenever something is updated in the profile.
This can be implemented by each user having a designated inbox for such 
notifications.

We explore how we can use the push model as a replacement for the (storage 
expensive) anonymous tag-hint system suggested in~\cite{anobe} to make 
decryption more efficient.

\begin{frame}<presentation>
  \begin{itemize}

    \item We investigate how we can use different strategies for delivering 
      messages to make \ac{ANOBE} more efficient:
      \begin{itemize}
        \item push-model,
        \item pull-model.
      \end{itemize}

    \item \ac{ANOBE} relies on IND-CCA2 public-key encryption.

    \item We also investigate in which situations we can replace it with 
      a semantically secure symmetric scheme.

    \item This would be one chance for making it more efficient.

  \end{itemize}
\end{frame}

% - What properties do we need from the PKE?
% - We might be able to use the EC algorithms in the NaCl library, if so, then 
%   we don't need to replace PKE with symmetric ciphers.
For performance reasons, we also look into a trade-off between using an 
IND-CCA2 \ac{PKE} scheme and a semantically secure symmetric encryption scheme 
in the \ac{ANOBE} construction.
The reason for this is that symmetric decryption is faster than asymmetric 
decryption.
This is an important factor for \acp{DOSN} during e.g.~news-feed aggregation 
when a user comes online.

\begin{frame}<presentation>
  \begin{itemize}
    \item \ac{BE} was designed for broadcasting a message to a dynamically 
      changing group.

    \item In these schemes any recipient can see who else can also decrypt the 
      message.

    \item The \ac{ANOBE} scheme removes this part, adding anonymity.

  \end{itemize}
\end{frame}

Furthermore, \ac{BE} is designed to broadcast a message to a dynamically 
changing group.
However, when a new user \(u\) is added to the group, we might want to give 
\(u\) access to old messages.
Similarly, when we remove a user \(u^\prime\) from a group, we might want to 
remove the access rights of \(u^\prime\).
We want to solve this as efficiently as possible, we do not want to re-encrypt 
unnecessarily much when we add or remove a friend to or from our network.


\section{Evaluation}\label{sec:Evaluation}
% - No need to over-promise.
% - Good synonyms for "looking at":
%   - investigating, exploring, evaluating, researching, additionally;
%   - if in relation to something else: contrasting, comparing.

To evaluate our work, we first apply the \ac{ANOBE} scheme without 
modifications in our \ac{AC} setting.
We evaluate its performance and compare that to the constructions mentioned as 
related work (Sect.~\ref{sec:RelatedWork}).
We then adapt the \ac{ANOBE} scheme to improve performance in the \ac{DOSN} 
context.
We prove the security properties of our constructions and evaluate their 
complexity.

The complexity is interesting to evaluate from two perspectives: the 
publisher's (profile owner's) and the subscriber's (friend's).
From the publisher's perspective it is interesting to investigate the 
complexity of key-storage size, communication complexity for publication and 
time complexity for encryption of new material.
From the subscriber's perspective the complexity of key-storage size and the 
time-complexity of aggregating the newest published messages are the most 
interesting aspects.


\section{Conclusion}
% XXX Write the conclusions
% - Ensure that the solution covers the needed properties.
\dots


\mode<presentation>{%
\section{Questions}
\begin{frame}
  \begin{center}
    Questions?
  \end{center}
\end{frame}
}


\mode<article>{%
\subsubsection{\ackname}

This work is based on the initial ideas of Oleksandr Bodriagov and Gunnar 
Kreitz.
It is funded by the Swedish Foundation for Strategic Research grant SSF 
FFL09-0086 and the Swedish Research Council grand VR 2009-3793.
Finally, we would like to thank the anonymous reviewers for valuable feedback.
}

\begin{frame}
\printbibliography{}
\end{frame}
